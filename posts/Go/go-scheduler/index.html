<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="文章简介：golang scheduler 相关的内容">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Go Scheduler" />
<meta property="og:description" content="文章简介：golang scheduler 相关的内容" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/Go/go-scheduler/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-08T07:33:02+08:00" />
<meta property="article:modified_time" content="2022-01-01T18:06:18+08:00" />

<title>Go Scheduler | Exfly Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css" >
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.bed7cd585cd154c1abbb8639e11c6cb3068190794c1148821250367c0a94f153.js" ></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><span>Exfly Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
<p><strong>home</strong></p>
</li>
<li>
<p>
  <a href="/docs/section/">section</a></p>
</li>
<li>
<p>
  <a href="/about/">about</a></p>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/exfly/" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Go Scheduler</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#coroutine-的工作方式">coroutine 的工作方式</a>
          <ul>
            <li><a href="#channel-的工作方式">channel 的工作方式</a></li>
          </ul>
        </li>
        <li><a href="#golang-goroutine-工作方式">golang goroutine 工作方式</a>
          <ul>
            <li><a href="#基本的组成元素和工作方式">基本的组成元素和工作方式</a></li>
          </ul>
        </li>
        <li><a href="#基于-goroutine-工作方式有哪些优点点缺点缺点如何规避">基于 goroutine 工作方式，有哪些优点点缺点，缺点如何规避</a>
          <ul>
            <li><a href="#优缺点">优缺点</a></li>
            <li><a href="#goroutine-pool">goroutine pool</a></li>
          </ul>
        </li>
        <li><a href="#ref">ref</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/posts/Go/go-scheduler/">Go Scheduler</a>
  </h1>
  
  <h5>August 8, 2021</h5>



  

  



<p>文章简介：golang scheduler 相关的内容</p>
<h2 id="简介">
  简介
  <a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a>
</h2>
<p>现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），他们都很复杂。golang 属于 两级线程模型，是由 goroutine 实现的, goroutine 是 golang 最重要的特性之一，具有使用成本低、消耗资源低、能效高等特点，官方宣称原生 goroutine 并发成千上万不成问题. 
  <a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E8%AB%87%E5%BE%AA%E5%BA%8F%E7%A8%8B%E5%BC%8F">CSP(通信顺序进程)</a> 是 
  <a href="https://zh.wikipedia.org/wiki/Go">golang</a> 中的并发模型。本片文档将带领读者深入理解 golang 的 goroutine 的工作方式。</p>
<p>stack 大小：</p>
<ul>
<li>goroutine：2KB</li>
<li>线程：8MB</li>
</ul>
<p>线程切换需要陷入内核；goroutine 只需要 getcontext 和 setcontext，30+ 个寄存器的读合写，非常快速</p>
<h2 id="coroutine-的工作方式">
  coroutine 的工作方式
  <a class="anchor" href="#coroutine-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h2>
<p>说到 goroutine，就不得不说一下 
  <a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">coroutine</a>。goroutine 是coroutine 在 golang 中的实现和优化。golang 作者之一 
  <a href="https://swtch.com/~rsc/">Russ Cox</a> 有实现轻量的 
  <a href="https://swtch.com/libtask/">libtask</a> ，400 行左右代码描述清楚了 coroutine 是怎么工作的。</p>
<blockquote>
<p>建议亲自下载代码，看一下具体的实现逻辑, 需要比较简单的 c 基础</p>
</blockquote>
<p>一个 coroutine 比较核心的工作包括：</p>
<ul>
<li>task 管理, 包括创建，销毁，切换等</li>
<li>coroutine 调度算法</li>
</ul>
<p>先看一个简单的使用例子:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/651d7b69a4f7b10c798dcd544e6a25fd7505632c/primes.c#L12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">primetask</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Channel <span style="color:#f92672">*</span>c, <span style="color:#f92672">*</span>nc;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> p, i;
</span></span><span style="display:flex;"><span>	c <span style="color:#f92672">=</span> arg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	p <span style="color:#f92672">=</span> chanrecvul(c);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">&gt;</span> goal)
</span></span><span style="display:flex;"><span>		taskexitall(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>quiet)
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, p);
</span></span><span style="display:flex;"><span>	nc <span style="color:#f92672">=</span> chancreate(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>), buffer);
</span></span><span style="display:flex;"><span>	taskcreate(primetask, nc, <span style="color:#ae81ff">32768</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(;;){
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> chanrecvul(c);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p)
</span></span><span style="display:flex;"><span>			chansendul(nc, i);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">taskmain</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	Channel <span style="color:#f92672">*</span>c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(argc<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		goal <span style="color:#f92672">=</span> atoi(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		goal <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;goal=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, goal);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	c <span style="color:#f92672">=</span> chancreate(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>), buffer);
</span></span><span style="display:flex;"><span>	taskcreate(primetask, c, <span style="color:#ae81ff">32768</span>); <span style="color:#75715e">// 创建 coroutine，开始执行任务 primetask
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		chansendul(c, i);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>会发现程序中没有常见的 c main 函数，实际是在 libtask 中实现了。整个程序是在一个线程中执行的，main 中创建了第一个 task，并启动 task 调度器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/main/task.c#L353
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">taskmainstart</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	taskname(<span style="color:#e6db74">&#34;taskmain&#34;</span>);
</span></span><span style="display:flex;"><span>	taskmain(taskargc, taskargv);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigaction sa, osa;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	memset(<span style="color:#f92672">&amp;</span>sa, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> sa);
</span></span><span style="display:flex;"><span>	sa.sa_handler <span style="color:#f92672">=</span> taskinfo;
</span></span><span style="display:flex;"><span>	sa.sa_flags <span style="color:#f92672">=</span> SA_RESTART;
</span></span><span style="display:flex;"><span>	sigaction(SIGQUIT, <span style="color:#f92672">&amp;</span>sa, <span style="color:#f92672">&amp;</span>osa);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef SIGINFO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sigaction(SIGINFO, <span style="color:#f92672">&amp;</span>sa, <span style="color:#f92672">&amp;</span>osa);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	argv0 <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	taskargc <span style="color:#f92672">=</span> argc;
</span></span><span style="display:flex;"><span>	taskargv <span style="color:#f92672">=</span> argv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(mainstacksize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		mainstacksize <span style="color:#f92672">=</span> <span style="color:#ae81ff">256</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span>	taskcreate(taskmainstart, nil, mainstacksize);
</span></span><span style="display:flex;"><span>	taskscheduler(); <span style="color:#75715e">// task 调度器启动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	fprint(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;taskscheduler returned in main!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	abort();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调度器的工作是从 runnable_queue 中获得一个可执行的任务，然后切换过去</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">taskscheduler</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	Task <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	taskdebug(<span style="color:#e6db74">&#34;scheduler enter&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(;;){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(taskcount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			exit(taskexitval);
</span></span><span style="display:flex;"><span>		t <span style="color:#f92672">=</span> taskrunqueue.head;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> nil){
</span></span><span style="display:flex;"><span>			fprint(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;no runnable tasks! %d tasks stalled</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, taskcount);
</span></span><span style="display:flex;"><span>			exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		deltask(<span style="color:#f92672">&amp;</span>taskrunqueue, t);
</span></span><span style="display:flex;"><span>		t<span style="color:#f92672">-&gt;</span>ready <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		taskrunning <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>		tasknswitch<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		taskdebug(<span style="color:#e6db74">&#34;run %d (%s)&#34;</span>, t<span style="color:#f92672">-&gt;</span>id, t<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>		contextswitch(<span style="color:#f92672">&amp;</span>taskschedcontext, <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>context);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//print(&#34;back in scheduler\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		taskrunning <span style="color:#f92672">=</span> nil;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(t<span style="color:#f92672">-&gt;</span>exiting){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>system)
</span></span><span style="display:flex;"><span>				taskcount<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>alltaskslot;
</span></span><span style="display:flex;"><span>			alltask[i] <span style="color:#f92672">=</span> alltask[<span style="color:#f92672">--</span>nalltask];
</span></span><span style="display:flex;"><span>			alltask[i]<span style="color:#f92672">-&gt;</span>alltaskslot <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>			free(t);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>coroutine 是如何切换的呢？由计算机的工作原理知道，程序的执行是根据 pc 寄存器中的位置取指令执行的，执行 task 需要 stack 和寄存器。寄存器中的数据就是一个 coroutine 的 上下文，记录下来，set 成其他的 上下文的 寄存器的值，即可达到切换 coroutine 的目的。由于不同平台的寄存器不同，指令集不同，需要区分平台做不同的事情:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux x86 平台的指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/651d7b69a4f7b10c798dcd544e6a25fd7505632c/asm.S#L43
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef NEEDX86CONTEXT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.globl SET
</span></span><span style="display:flex;"><span>SET:
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>esp), <span style="color:#f92672">%</span>eax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>fs
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>es
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">16</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ds
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">76</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ss
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">20</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>edi
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">24</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>esi
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">28</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ebp
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">36</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ebx
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">40</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>edx
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">44</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ecx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">72</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>esp
</span></span><span style="display:flex;"><span>	pushl	<span style="color:#ae81ff">60</span>(<span style="color:#f92672">%</span>eax)	<span style="color:#75715e">/* new %eip */</span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">48</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>eax
</span></span><span style="display:flex;"><span>	ret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.globl GET
</span></span><span style="display:flex;"><span>GET:
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>esp), <span style="color:#f92672">%</span>eax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>fs, <span style="color:#ae81ff">8</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>es, <span style="color:#ae81ff">12</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ds, <span style="color:#ae81ff">16</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ss, <span style="color:#ae81ff">76</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>edi, <span style="color:#ae81ff">20</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>esi, <span style="color:#ae81ff">24</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ebp, <span style="color:#ae81ff">28</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ebx, <span style="color:#ae81ff">36</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>edx, <span style="color:#ae81ff">40</span>(<span style="color:#f92672">%</span>eax)		 
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ecx, <span style="color:#ae81ff">44</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">48</span>(<span style="color:#f92672">%</span>eax)	<span style="color:#75715e">/* %eax */</span>
</span></span><span style="display:flex;"><span>	movl	(<span style="color:#f92672">%</span>esp), <span style="color:#f92672">%</span>ecx	<span style="color:#75715e">/* %eip */</span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ecx, <span style="color:#ae81ff">60</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>	leal	<span style="color:#ae81ff">4</span>(<span style="color:#f92672">%</span>esp), <span style="color:#f92672">%</span>ecx	<span style="color:#75715e">/* %esp */</span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>ecx, <span style="color:#ae81ff">72</span>(<span style="color:#f92672">%</span>eax)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">44</span>(<span style="color:#f92672">%</span>eax), <span style="color:#f92672">%</span>ecx	<span style="color:#75715e">/* restore %ecx */</span>
</span></span><span style="display:flex;"><span>	movl	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">%</span>eax
</span></span><span style="display:flex;"><span>	ret
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c 中的 Context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Context
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ucontext_t	uc;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>到此，用户级 task( coroutine )切换/调度/运行工作基本可以正常工作了。</p>
<p>总结一下：
coroutine 是单线程程序，可以串行的跑多个任务；多个任务通过一个 scheduler task 切换；切换的方式是通过替换cpu的寄存器实现的；切换的过程 os kernel 是不知道的; 由于 context switch 只是执行 30+ 个汇编指令，（os context switch 需要至少两次 context switch，以及一些状态维护，相比较来说）开销更小，cpu 的利用率会提高不少；使用同步的方式写出可以异步执行的代码，符合人的普遍思考方式。</p>
<h3 id="channel-的工作方式">
  channel 的工作方式
  <a class="anchor" href="#channel-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>这一节内容和协程机理没有直接联系，但是因为channel总是伴随着goroutine出现，所以我们 顺便了解一下channel的原理也颇有好处。幸运的是，libtask 中也提供了channel的参考实现.</p>
<p>channel 分为有 buf 和 无 buf channel</p>
<h4 id="对于无-buf-的-channel">
  对于无 buf 的 channel
  <a class="anchor" href="#%e5%af%b9%e4%ba%8e%e6%97%a0-buf-%e7%9a%84-channel">#</a>
</h4>
<p>某一个 task 执行 chansendul 会直接将当前 task 加入 channel 的 send 队列中，然后触发一次 context switch。由于此时 channel 的 task 已经不在 taskrunqueue 中，发送数据到 channel 的 task 不会再被 taskscheduler 调度到，直到 chanrecvul task 被调度，且消费 channel 中的数据，此时 发送端 task 重新被放到可执行队列中。</p>
<h4 id="对于-有-buf-的-channel">
  对于 有 buf 的 channel
  <a class="anchor" href="#%e5%af%b9%e4%ba%8e-%e6%9c%89-buf-%e7%9a%84-channel">#</a>
</h4>
<p>某一个 task 执行 chansendul，如果 channel buf 没有满，则会将数据复制到 channel buf 中，task 会继续执行。
如果 channel buf 已满，会将 send task 进 channel send 等待队列，并让出 cpu。
chanrecvul task 接受数据时候，如果 channel buf 不为空，则会直接消费 buf 中的数据；如果 buf 为空，则会 加入 channel 的 recv 等待队列，并让出 cpu，直到有新的数据被send 到 channel 为止。</p>
<h2 id="golang-goroutine-工作方式">
  golang goroutine 工作方式
  <a class="anchor" href="#golang-goroutine-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h2>
<p>了解了传统 coroutine 的实现方式，我们来看一下 golang 的 goroutine 的工作方式.</p>
<p>golang 实现了一种叫做 工作窃取任务调度.</p>
<blockquote>
<p>具体的功能介绍见: 
  <a href="https://hxzhao527.github.io/2018/10/18/%E7%BF%BB%E8%AF%91-The-Go-scheduler/">[翻译]The Go scheduler</a>
具体的更详细的源码分析见：
  <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go 调度器</a></p>
</blockquote>
<h3 id="基本的组成元素和工作方式">
  基本的组成元素和工作方式
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e7%bb%84%e6%88%90%e5%85%83%e7%b4%a0%e5%92%8c%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>
  <img src="/media/img/golang/scheduler-syscall.jpg" alt="GMP" /></p>
<p>G、P、M</p>
<ul>
<li>G: 表示 Goroutine，每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。</li>
<li>P: Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。</li>
<li>M: Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</li>
</ul>
<p>任务队列共有两种，一种是 p 上的本地队列，另一种是 global queue。当使用 go 关键词启动一个新的 goroutine 的时候，这既可能是全局的运行队列，也可能是处理器本地的运行队列。

  <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L5646">runtime.runqput</a> 可知，</p>
<ol>
<li>当 next 为 true 时，会将 Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务；</li>
<li>当 next 为 false 并且本地队列还有剩余空间，Goroutine 会被放到本地运行队列上；</li>
<li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 
  <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L5681">runtime.runqputslow</a> 添加到调度器持有的全局运行队列上；</li>
</ol>
<p>调度可执行任务的时候。

  <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2977">runtime.schedule</a> 函数会从下面几个地方查找待执行的 Goroutine：</p>
<ol>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 
  <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2482">runtime.findrunnable</a> 进行阻塞地查找 Goroutine.</li>
</ol>
<p>如果处理器没有任务可处理，它会按以下规则来执行，直到满足某一条规则：</p>
<ul>
<li>从本地队列获取任务</li>
<li>从全局队列获取任务</li>
<li>从网络轮询器获取任务</li>
<li>从其它的处理器的本地队列窃取任务</li>
</ul>
<h2 id="基于-goroutine-工作方式有哪些优点点缺点缺点如何规避">
  基于 goroutine 工作方式，有哪些优点点缺点，缺点如何规避
  <a class="anchor" href="#%e5%9f%ba%e4%ba%8e-goroutine-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%82%b9%e7%82%b9%e7%bc%ba%e7%82%b9%e7%bc%ba%e7%82%b9%e5%a6%82%e4%bd%95%e8%a7%84%e9%81%bf">#</a>
</h2>
<h3 id="优缺点">
  优缺点
  <a class="anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">#</a>
</h3>
<p>优点：</p>
<ol>
<li>由于 golang goroutine 实现的 scheduler 比较简单，在大量 goroutine 调度时候性能消耗相比较 os thread 的调度来说会低至少一个数量级。</li>
</ol>
<p>缺点：</p>
<ol>
<li>scheduler 的实现细节非常多，复杂</li>
<li>用户想 hack 自己的线程模型基本不可能 (当然 golang 的 scheduler 已经足够优秀了)</li>
</ol>
<h3 id="goroutine-pool">
  goroutine pool
  <a class="anchor" href="#goroutine-pool">#</a>
</h3>
<blockquote>
<p>10M(百万) goroutine 执行轻量操作会出现瓶颈，需要考虑 goroutine pool 来做优化了</p>
</blockquote>
<p>golang 有 gc，goroutine 的创建与删除还是需要申请内存的，如果可以，尽量使用 pool，让 goroutine调度压力尽量小一点，用户程序复用 goroutine。可以使用 goroutine pool 实现 goroutine 的复用。同时不好的 pool 实现也会让一把锁破坏掉好的性能。是否使用，需要视情况而定.</p>
<h2 id="ref">
  ref
  <a class="anchor" href="#ref">#</a>
</h2>
<ul>
<li>
<p>
  <a href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool">GMP 并发调度器深度解析之手撸一个高性能 goroutine pool</a></p>
</li>
<li>
<p>
  <a href="https://github.com/golang/go/blob/master/src/runtime/HACKING.md">Scheduler structures</a></p>
</li>
<li>
<p>
  <a href="https://github.com/golang/proposal">golang/proposal</a></p>
</li>
<li>
<p>
  <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">Scalable Go Scheduler Design Doc</a></p>
</li>
<li>
<p>
  <a href="https://xie.infoq.cn/article/a6948402be688dba530094e9b">Scalable Go Scheduler Design Doc -zh</a> 
  <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">Scalable Go Scheduler Design Doc -en</a></p>
</li>
<li>
<p>
  <a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h">第一代 Go Preemptive Scheduler Design Doc</a></p>
</li>
<li>
<p>
  <a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling Multithreaded Computations by Work Stealing</a></p>
</li>
<li>
<p>
  <a href="https://zhuanlan.zhihu.com/p/95056679">万字长文深入浅出 Golang Runtime</a></p>
</li>
<li>
<p>
  <a href="https://rakyll.org/scheduler/">Go&rsquo;s work-stealing scheduler</a></p>
</li>
<li>
<p>
  <a href="https://github.com/golang/go/blob/master/src/runtime/proc.go">The Go runtime scheduler source</a></p>
</li>
<li>
<p>
  <a href="https://morsmachine.dk/go-scheduler">go-scheduler</a> 
  <a href="https://hxzhao527.github.io/2018/10/18/%E7%BF%BB%E8%AF%91-The-Go-scheduler/">go-scheduler-zh</a></p>
</li>
<li>
<p>
  <a href="https://mp.weixin.qq.com/s/wE_z7MxDJjIVDN16578tDw">Go 语言十年而立，Go2 蓄势待发</a></p>
</li>
</ul></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/exfly/HugoBlog/commit/b424636cc44e79e3baeeb64abf6980859bedee5e" title='最后修改者 exfly | January 1, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>January 1, 2022</span>
    </a>
  </div>



</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#coroutine-的工作方式">coroutine 的工作方式</a>
          <ul>
            <li><a href="#channel-的工作方式">channel 的工作方式</a></li>
          </ul>
        </li>
        <li><a href="#golang-goroutine-工作方式">golang goroutine 工作方式</a>
          <ul>
            <li><a href="#基本的组成元素和工作方式">基本的组成元素和工作方式</a></li>
          </ul>
        </li>
        <li><a href="#基于-goroutine-工作方式有哪些优点点缺点缺点如何规避">基于 goroutine 工作方式，有哪些优点点缺点，缺点如何规避</a>
          <ul>
            <li><a href="#优缺点">优缺点</a></li>
            <li><a href="#goroutine-pool">goroutine pool</a></li>
          </ul>
        </li>
        <li><a href="#ref">ref</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












