<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="TODO: golang scheduler 相关的内容">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Go Scheduler" />
<meta property="og:description" content="TODO: golang scheduler 相关的内容" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/Go/go-scheduler/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-08T07:33:02&#43;08:00" />
<meta property="article:modified_time" content="2021-08-08T14:33:24&#43;08:00" />

<title>Go Scheduler | Exfly Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css" >
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.12530a451e610369d0fcd518436c96e0c51628659f69ccd126f290a9e8121e7a.js" ></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/"><span>Exfly Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
<p><strong>example</strong></p>
</li>
<li>
<p>
  <a href="/docs/example/">section</a></p>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Go Scheduler</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#coroutine-的工作方式">coroutine 的工作方式</a>
          <ul>
            <li><a href="#channel-的工作方式">channel 的工作方式</a></li>
          </ul>
        </li>
        <li><a href="#golang-goroutine-工作方式">golang goroutine 工作方式</a>
          <ul>
            <li><a href="#基本的组成元素和工作方式">基本的组成元素和工作方式</a></li>
            <li><a href="#基本要素">基本要素</a></li>
          </ul>
        </li>
        <li><a href="#基于-goroutine-工作方式有哪些有点缺点缺点如何规避">基于 goroutine 工作方式，有哪些有点缺点，缺点如何规避</a>
          <ul>
            <li><a href="#优缺点">优缺点</a></li>
            <li><a href="#goroutine-pool">goroutine pool</a></li>
          </ul>
        </li>
        <li><a href="#ref">ref</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/posts/Go/go-scheduler/">Go Scheduler</a>
  </h1>
  
  <h5>August 8, 2021</h5>



  

  



<p>TODO: golang scheduler 相关的内容</p>
<h2 id="简介">
  简介
  <a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a>
</h2>
<p>现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），他们都很复杂。golang 属于 两级线程模型，是由 goroutine 实现的, goroutine 是 golang 最重要的特性之一，具有使用成本低、消耗资源低、能效高等特点，官方宣称原生 goroutine 并发成千上万不成问题. 
  <a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E8%AB%87%E5%BE%AA%E5%BA%8F%E7%A8%8B%E5%BC%8F">CSP(通信顺序进程)</a> 是 
  <a href="https://zh.wikipedia.org/wiki/Go">golang</a> 中的并发模型。本片文档将带领读者深入理解 golang 的 goroutine 的工作方式。</p>
<p>stack 大小：</p>
<ul>
<li>goroutine：2KB</li>
<li>线程：8MB</li>
</ul>
<p>线程切换需要陷入内核；goroutine 只需要 getcontext 和 setcontext，30+ 个寄存器的读合写，非常快速</p>
<h2 id="coroutine-的工作方式">
  coroutine 的工作方式
  <a class="anchor" href="#coroutine-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h2>
<p>说到 goroutine，就不得不说一下 
  <a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">coroutine</a>。goroutine 是coroutine 在 golang 中的实现和优化。golang 作者之一 
  <a href="https://swtch.com/~rsc/">Russ Cox</a> 有实现轻量的 
  <a href="https://swtch.com/libtask/">libtask</a> ，400 行左右代码描述清楚了 coroutine 是怎么工作的。</p>
<blockquote>
<p>建议亲自下载代码，看一下具体的实现逻辑, 需要比较简单的 c 基础</p>
</blockquote>
<p>一个 coroutine 比较核心的工作包括：</p>
<ul>
<li>task 管理, 包括创建，销毁，切换等</li>
<li>coroutine 调度算法</li>
</ul>
<p>先看一个简单的使用例子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/651d7b69a4f7b10c798dcd544e6a25fd7505632c/primes.c#L12
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">primetask</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg)
{
	Channel <span style="color:#f92672">*</span>c, <span style="color:#f92672">*</span>nc;
	<span style="color:#66d9ef">int</span> p, i;
	c <span style="color:#f92672">=</span> arg;

	p <span style="color:#f92672">=</span> chanrecvul(c);
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">&gt;</span> goal)
		taskexitall(<span style="color:#ae81ff">0</span>);
	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>quiet)
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, p);
	nc <span style="color:#f92672">=</span> chancreate(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>), buffer);
	taskcreate(primetask, nc, <span style="color:#ae81ff">32768</span>);
	<span style="color:#66d9ef">for</span>(;;){
		i <span style="color:#f92672">=</span> chanrecvul(c);
		<span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p)
			chansendul(nc, i);
	}
}

<span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">taskmain</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
	<span style="color:#66d9ef">int</span> i;
	Channel <span style="color:#f92672">*</span>c;

	<span style="color:#66d9ef">if</span>(argc<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>)
		goal <span style="color:#f92672">=</span> atoi(argv[<span style="color:#ae81ff">1</span>]);
	<span style="color:#66d9ef">else</span>
		goal <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	printf(<span style="color:#e6db74">&#34;goal=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, goal);

	c <span style="color:#f92672">=</span> chancreate(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>), buffer);
	taskcreate(primetask, c, <span style="color:#ae81ff">32768</span>); <span style="color:#75715e">// 创建 coroutine，开始执行任务 primetask
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;; i<span style="color:#f92672">++</span>)
		chansendul(c, i);
}
</code></pre></div><p>会发现程序中没有常见的 c main 函数，实际是在 libtask 中实现了。整个程序是在一个线程中执行的，main 中创建了第一个 task，并启动 task 调度器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/main/task.c#L353
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">taskmainstart</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v)
{
	taskname(<span style="color:#e6db74">&#34;taskmain&#34;</span>);
	taskmain(taskargc, taskargv);
}

<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
	<span style="color:#66d9ef">struct</span> sigaction sa, osa;

	memset(<span style="color:#f92672">&amp;</span>sa, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> sa);
	sa.sa_handler <span style="color:#f92672">=</span> taskinfo;
	sa.sa_flags <span style="color:#f92672">=</span> SA_RESTART;
	sigaction(SIGQUIT, <span style="color:#f92672">&amp;</span>sa, <span style="color:#f92672">&amp;</span>osa);

<span style="color:#75715e">#ifdef SIGINFO
</span><span style="color:#75715e"></span>	sigaction(SIGINFO, <span style="color:#f92672">&amp;</span>sa, <span style="color:#f92672">&amp;</span>osa);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
	argv0 <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">0</span>];
	taskargc <span style="color:#f92672">=</span> argc;
	taskargv <span style="color:#f92672">=</span> argv;

	<span style="color:#66d9ef">if</span>(mainstacksize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
		mainstacksize <span style="color:#f92672">=</span> <span style="color:#ae81ff">256</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span>;
	taskcreate(taskmainstart, nil, mainstacksize);
	taskscheduler(); <span style="color:#75715e">// task 调度器启动
</span><span style="color:#75715e"></span>	fprint(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;taskscheduler returned in main!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	abort();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>调度器的工作是从 runnable_queue 中获得一个可执行的任务，然后切换过去</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">taskscheduler</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#66d9ef">int</span> i;
	Task <span style="color:#f92672">*</span>t;

	taskdebug(<span style="color:#e6db74">&#34;scheduler enter&#34;</span>);
	<span style="color:#66d9ef">for</span>(;;){
		<span style="color:#66d9ef">if</span>(taskcount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
			exit(taskexitval);
		t <span style="color:#f92672">=</span> taskrunqueue.head;
		<span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> nil){
			fprint(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;no runnable tasks! %d tasks stalled</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, taskcount);
			exit(<span style="color:#ae81ff">1</span>);
		}
		deltask(<span style="color:#f92672">&amp;</span>taskrunqueue, t);
		t<span style="color:#f92672">-&gt;</span>ready <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		taskrunning <span style="color:#f92672">=</span> t;
		tasknswitch<span style="color:#f92672">++</span>;
		taskdebug(<span style="color:#e6db74">&#34;run %d (%s)&#34;</span>, t<span style="color:#f92672">-&gt;</span>id, t<span style="color:#f92672">-&gt;</span>name);
		contextswitch(<span style="color:#f92672">&amp;</span>taskschedcontext, <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>context);
<span style="color:#75715e">//print(&#34;back in scheduler\n&#34;);
</span><span style="color:#75715e"></span>		taskrunning <span style="color:#f92672">=</span> nil;
		<span style="color:#66d9ef">if</span>(t<span style="color:#f92672">-&gt;</span>exiting){
			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>system)
				taskcount<span style="color:#f92672">--</span>;
			i <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>alltaskslot;
			alltask[i] <span style="color:#f92672">=</span> alltask[<span style="color:#f92672">--</span>nalltask];
			alltask[i]<span style="color:#f92672">-&gt;</span>alltaskslot <span style="color:#f92672">=</span> i;
			free(t);
		}
	}
}
</code></pre></div><p>coroutine 是如何切换的呢？由计算机的工作原理知道，程序的执行是根据 pc 寄存器中的位置取指令执行的，执行 task 需要 stack 和寄存器。寄存器中的数据就是一个 coroutine 的 上下文，记录下来，set 成其他的 上下文的 寄存器的值，即可达到切换 coroutine 的目的。由于不同平台的寄存器不同，指令集不同，需要区分平台做不同的事情:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// linux arm 平台的指令
</span><span style="color:#75715e">// https://github.com/mixinlib/libtask/blob/651d7b69a4f7b10c798dcd544e6a25fd7505632c/asm.S#L224
</span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef NEEDARMCONTEXT
</span><span style="color:#75715e"></span>.globl GET
GET:
	str	r1, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">4</span>]
	str	r2, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>]
	str	r3, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">12</span>]
	str	r4, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>]
	str	r5, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">20</span>]
	str	r6, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">24</span>]
	str	r7, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">28</span>]
	str	r8, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">32</span>]
	str	r9, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">36</span>]
	str	r10, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">40</span>]
	str	r11, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">44</span>]
	str	r12, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">48</span>]
	str	r13, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">52</span>]
	str	r14, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">56</span>]
	<span style="color:#75715e">/* store 1 as r0-to-restore */</span>
	mov	r1, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>
	str	r1, [r0]
	<span style="color:#75715e">/* return 0 */</span>
	mov	r0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
	mov	pc, lr

.globl SET
SET:
	ldr	r1, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">4</span>]
	ldr	r2, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>]
	ldr	r3, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">12</span>]
	ldr	r4, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>]
	ldr	r5, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">20</span>]
	ldr	r6, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">24</span>]
	ldr	r7, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">28</span>]
	ldr	r8, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">32</span>]
	ldr	r9, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">36</span>]
	ldr	r10, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">40</span>]
	ldr	r11, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">44</span>]
	ldr	r12, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">48</span>]
	ldr	r13, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">52</span>]
	ldr	r14, [r0,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">56</span>]
	ldr	r0, [r0]
	mov	pc, lr
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// c 中的 Context
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Context
{
	ucontext_t	uc;
};
</code></pre></div><p>到此，用户级 task( coroutine )切换/调度/运行工作基本可以正常工作了。</p>
<p>总结一下：
coroutine 是单线程程序，可以串行的跑多个任务；多个任务通过一个 scheduler task 切换；切换的方式是通过替换cpu的寄存器实现的；切换的过程 os kernel 是不知道的; 由于 context switch 只是执行 30+ 个汇编指令，（os context switch 需要至少两次 context switch，以及一些状态维护，相比较来说）开销更小，cpu 的利用率会提高不少；使用同步的方式写出可以异步执行的代码，符合人的普遍思考方式。</p>
<h3 id="channel-的工作方式">
  channel 的工作方式
  <a class="anchor" href="#channel-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>这一节内容和协程机理没有直接联系，但是因为channel总是伴随着goroutine出现，所以我们 顺便了解一下channel的原理也颇有好处。幸运的是，libtask 中也提供了channel的参考实现.</p>
<p>channel 分为有 buf 和 无 buf channel</p>
<h4 id="对于无-buf-的-channel">
  对于无 buf 的 channel
  <a class="anchor" href="#%e5%af%b9%e4%ba%8e%e6%97%a0-buf-%e7%9a%84-channel">#</a>
</h4>
<p>某一个 task 执行 chansendul 会直接将当前 task 加入 channel 的 send 队列中，然后触发一次 context switch。由于此时 channel 的 task 已经不在 taskrunqueue 中，发送数据到 channel 的 task 不会再被 taskscheduler 调度到，直到 chanrecvul task 被调度，且消费 channel 中的数据，此时 发送端 task 重新被放到可执行队列中。</p>
<h4 id="对于-有-buf-的-channel">
  对于 有 buf 的 channel
  <a class="anchor" href="#%e5%af%b9%e4%ba%8e-%e6%9c%89-buf-%e7%9a%84-channel">#</a>
</h4>
<p>某一个 task 执行 chansendul，如果 channel buf 没有满，则会将数据复制到 channel buf 中，task 会继续执行。
如果 channel buf 已满，会将 send task 进 channel send 等待队列，并让出 cpu。
chanrecvul task 接受数据时候，如果 channel buf 不为空，则会直接消费 buf 中的数据；如果 buf 为空，则会 加入 channel 的 recv 等待队列，并让出 cpu，直到有新的数据被send 到 channel 为止。</p>
<h2 id="golang-goroutine-工作方式">
  golang goroutine 工作方式
  <a class="anchor" href="#golang-goroutine-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h2>
<p>了解了传统 coroutine 的实现方式，我们来看一下 golang 的 goroutine 的工作方式</p>
<h3 id="基本的组成元素和工作方式">
  基本的组成元素和工作方式
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e7%bb%84%e6%88%90%e5%85%83%e7%b4%a0%e5%92%8c%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#</a>
</h3>
<h3 id="基本要素">
  基本要素
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%b4%a0">#</a>
</h3>
<p>G、P、M</p>
<ul>
<li>G: 表示 Goroutine，每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。</li>
<li>P: Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。</li>
<li>M: Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</li>
</ul>
<h2 id="基于-goroutine-工作方式有哪些有点缺点缺点如何规避">
  基于 goroutine 工作方式，有哪些有点缺点，缺点如何规避
  <a class="anchor" href="#%e5%9f%ba%e4%ba%8e-goroutine-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b%e6%9c%89%e7%82%b9%e7%bc%ba%e7%82%b9%e7%bc%ba%e7%82%b9%e5%a6%82%e4%bd%95%e8%a7%84%e9%81%bf">#</a>
</h2>
<h3 id="优缺点">
  优缺点
  <a class="anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">#</a>
</h3>
<h3 id="goroutine-pool">
  goroutine pool
  <a class="anchor" href="#goroutine-pool">#</a>
</h3>
<h2 id="ref">
  ref
  <a class="anchor" href="#ref">#</a>
</h2>
<ul>
<li>
<p>
  <a href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool">GMP 并发调度器深度解析之手撸一个高性能 goroutine pool</a></p>
</li>
<li>
<p>
  <a href="https://github.com/golang/go/blob/master/src/runtime/HACKING.md">Scheduler structures</a></p>
</li>
<li>
<p>
  <a href="https://github.com/golang/proposal">golang/proposal</a></p>
</li>
<li>
<p>
  <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">Scalable Go Scheduler Design Doc</a></p>
</li>
<li>
<p>
  <a href="https://xie.infoq.cn/article/a6948402be688dba530094e9b">Scalable Go Scheduler Design Doc -zh</a> 
  <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">Scalable Go Scheduler Design Doc -en</a></p>
</li>
<li>
<p>
  <a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h">第一代 Go Preemptive Scheduler Design Doc</a></p>
</li>
<li>
<p>
  <a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling Multithreaded Computations by Work Stealing</a></p>
</li>
</ul></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/exfly/HugoBlog/commit/4aa4ab3638a9df366897d0f8d96f1b00c96aaec0" title='最后修改者 exfly | August 8, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>August 8, 2021</span>
    </a>
  </div>



</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#coroutine-的工作方式">coroutine 的工作方式</a>
          <ul>
            <li><a href="#channel-的工作方式">channel 的工作方式</a></li>
          </ul>
        </li>
        <li><a href="#golang-goroutine-工作方式">golang goroutine 工作方式</a>
          <ul>
            <li><a href="#基本的组成元素和工作方式">基本的组成元素和工作方式</a></li>
            <li><a href="#基本要素">基本要素</a></li>
          </ul>
        </li>
        <li><a href="#基于-goroutine-工作方式有哪些有点缺点缺点如何规避">基于 goroutine 工作方式，有哪些有点缺点，缺点如何规避</a>
          <ul>
            <li><a href="#优缺点">优缺点</a></li>
            <li><a href="#goroutine-pool">goroutine pool</a></li>
          </ul>
        </li>
        <li><a href="#ref">ref</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












